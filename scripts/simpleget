#!/usr/bin/python2.7
# -*- coding: utf-8 -*-

from datetime import date
from argparse import ArgumentParser
from os import listdir, environ, umask, makedirs, chdir
from os.path import join, isfile, splitext, isdir, getsize
from requests import get, post
from xml.etree import ElementTree
from re import match, sub, I
from shutil import move, rmtree
try:
    import json
except ImportError:
    import simplejson as json
import sys
# from pprint import pprint, pformat

import logging
log = logging.getLogger(__name__)

# Episodes
EPISODES_REGEX = r'(.+)[\. ][s|S]?([0-9]{1,2})[x|X|e|E]([0-9]{2}).*(720p.*)'
EPISODES_DIR = u'/media/storage/TV Shows'
# Movies
MOVIES_REGEX = r'(?P<title>.+) \((?P<year>.+)\) \[1080p\]'
MOVIES_DIR = u'/media/storage/Movies'


class Episode:
    def __init__(self, series, season, episode):
        """ """
        self.series = series
        self.season = int(season)
        self.episode = int(episode)
        log.debug(u'Create episode for {s} ({se}x{e:>02})'.format(s=self.series, se=self.season, e=self.episode))  # noqa: E501

    def exists(self):
        """ Check if this episode exists in Kodi """
        kodi = KodiRPC()
        # Get all episodes for this season
        log.debug(u'Get all episodes for "{t}", Season {s}'.format(t=self.series, s=self.season))  # noqa: E501
        episodes = kodi.VideoLibrary.GetEpisodes(tvshowid=self.series.id, season=self.season)  # noqa: E501
        # Corner case when no episodes are available yet
        episodes = episodes[u'result'][u'episodes'] if u'episodes' in episodes[u'result'] else []  # noqa: E501
        # Compile search string to match in retrieved episodes (SxEE)
        search = u'{s}x{e:>02}'.format(s=self.season, e=self.episode)
        log.debug(u'Search for episode {e} in available episodes'.format(e=search))  # noqa: E501
        # Check if any of the labels match the season/episode format
        return any(map(lambda x: x[u'label'][0:len(search)] == search, episodes))  # noqa: E501

    def __eq__(self, other):
        """ Compare against other Episodes """
        if not isinstance(other, Episode):
            return False
        return self.series.id == other.series.id and self.season == other.season and self.episode == other.episode


class Trigram:
    def __init__(self, s, id=False):
        """ """
        # log.debug(u'Trigram created for "{s}"'.format(s=s))
        self.s = unicode(sub(r'[ ]{2,}', u' ', s.replace('.', ' ').replace('_', ' ')))  # noqa
        # Create trigram list, clean up string to improve matching
        self.lut = Trigram.get_ngram(sub(r'[\W_]+', '', self.s).lower())
        self.id = id

    def __eq__(self, other):
        """ """
        if not isinstance(other, Trigram):
            return False
        return self.similarity(other) >= 0.9

    def __str__(self):
        """ """
        return self.s

    @staticmethod
    def get_ngram(s, n=3):
        """ Create chunks of n-size for provided string """
        return zip(*[s[i:] for i in range(n)])

    def similarity(self, other):
        """ """
        other = Trigram(other) if not isinstance(other, Trigram) else other
        match = len(list(set(self.lut) & set(other.lut)))
        # Calculate the match between 0.0 and 1.0 (higher is better)
        return round(float(match) / ((len(self.lut) + len(other.lut)) / 2), 2)


class KodiRPC:
    """ Wrap the Kodi JSON API.

    :param host: Host name for the Kodi JSON server.
    :param port: Port to connect on.
    :param username: Username for Kodi.
    :param password: Password for Kodi.
    """

    def __init__(self, host='localhost', port=8080, username=False, password=False):
        self.url = 'http://{h}:{p}/jsonrpc'.format(h=host, p=port)
        self.username = username
        self.password = password

    def __call__(self, **kwargs):
        method = '.'.join(map(str, self.n))
        self.n = []
        return KodiRPC.__dict__['request'](self, method, kwargs)

    def __getattr__(self, name):
        if 'n' not in self.__dict__:
            self.n = []
        self.n.append(name)
        return self

    def request(self, method, kwargs):
        # Create JSON request
        data = [{'method': method, 'params': kwargs, 'jsonrpc': '2.0', 'id': 'json'}]
        data = json.JSONEncoder().encode(data)
        # Send data to transmission
        response = post(self.url, data=data, auth=(self.username, self.password))
        response.raise_for_status()
        # Decode and return the response
        result = response.json()[0]
        if u'error' in result:
            raise ValueError(result[u'error'][u'message'])
        return result


class TransmissionRPC:
    """ Wrap the Transmission JSON API """
    def __init__(self, host=u'localhost', port=9091, username=False, password=False):
        self.url = u'http://{h}:{p}/transmission/rpc'.format(h=host, p=port)
        self.username = username
        self.password = password
        self.sid = None

    def __call__(self, **kwargs):
        method = '.'.join(map(str, self.n))
        self.n = []
        return TransmissionRPC.__dict__[u'request'](self, method, kwargs)

    def __getattr__(self, name):
        if 'n' not in self.__dict__:
            self.n = []
        self.n.append(name)
        return self

    def request(self, method, kwargs):
        # Create JSON request
        data = {u'method': method.replace('_', '-'), u'arguments': kwargs}
        data = json.JSONEncoder().encode(data)
        # Send data to transmission
        response = post(self.url, data=data, auth=(self.username, self.password),
                        headers={u'X-Transmission-Session-Id': self.sid})
        if 409 == response.status_code:
            self.sid = response.headers[u'X-Transmission-Session-Id']
            return self.request(method, kwargs)
        response.raise_for_status()
        # Decode and return the response
        result = response.json()
        if u'success' != result[u'result']:
            raise ValueError(result[u'result'])
        return result


def clean():
    """ Clean the Kodi library. """
    log.info(u'Cleaning Kodi Video Library')
    kodi = KodiRPC()
    kodi.VideoLibrary.Clean()


def match_trigram(pattern, string):
    """ """
    log.info(u'"{p}" matches against "{s}" by {m}%'.format(m=int(Trigram(pattern).similarity(string) * 100), p=pattern, s=string))


def find(haystack, needle, match=0.9):
    """ """
    found = filter(lambda h: h.similarity(needle) >= match, haystack)
    if len(found) > 0:
        # Find the series that matches the most
        return max(found, key=lambda x: x.similarity(needle))
    raise ValueError(u'No needle found in the haystack for "{s}"'.format(s=needle.s))


def get_movies():
    """ Create trigrams for each directory """
    kodi = KodiRPC()
    # Get all available TV shows from Kodi
    movies = kodi.VideoLibrary.GetMovies()[u'result']['movies']
    return [Trigram(m[u'label'], m[u'movieid']) for m in movies]


def get_series():
    """ Create trigrams for each directory """
    kodi = KodiRPC()
    # Get all available TV shows from Kodi
    tvshows = kodi.VideoLibrary.GetTVShows()[u'result']['tvshows']
    return [Trigram(s[u'label'], s[u'tvshowid']) for s in tvshows]


def get_rss(url):
    """ Get RSS feed """
    log.info(u'Download RSS from "{r}"'.format(r=url))
    response = get(url)
    response.raise_for_status()
    return ElementTree.fromstring(response.content)


def kodi_episodes():
    """ """
    kodi = KodiRPC()
    # Display all available TV shows from Kodi
    tvshows = kodi.VideoLibrary.GetTVShows()[u'result']['tvshows']
    for tvshow in sorted(tvshows, key=lambda x: x[u'label']):
        log.info(u'{id:>04}: {l}'.format(l=tvshow[u'label'], id=tvshow[u'tvshowid']))


def kodi_movies():
    """ """
    kodi = KodiRPC()
    # Display all available movies from Kodi
    movies = kodi.VideoLibrary.GetMovies()[u'result']['movies']
    for movie in sorted(movies, key=lambda x: x[u'label']):
        log.info(u'{id:>04}: {l}'.format(l=movie[u'label'], id=movie[u'movieid']))


def put_transmission(name, magnet, host, username, password):
    """ """
    log.info(u'Uploading "{n}" to transmission'.format(n=name))
    # Add the magnet link to transmission
    rpc = TransmissionRPC(host=host, username=username, password=password)
    log.debug(u'Adding torrent link: "{m}"'.format(m=magnet))
    rpc.torrent_add(filename=magnet)


def parse():
    """ """
    parser = ArgumentParser()
    # Shared
    parser.add_argument('--khost', default='localhost', help='Kodi host name')
    parser.add_argument('--kuser', default=False, help='Kodi user name')
    parser.add_argument('--kpass', default=False, help='Kodi password')
    parser.add_argument('--debug', help='Enable debug mode', action="store_true", default=False)
    parser.add_argument('--log', help='Log file')
    # Sub parsers for either pre/postqueue mode
    subparsers = parser.add_subparsers(help='An execution mode must be selected', dest='mode')
    # Prequeue
    prequeue = subparsers.add_parser('prequeue', help='Enable prequeue mode')
    prequeue.add_argument('--everything', help='Download all matched items from the feed', action="store_true", default=False)
    prequeue.add_argument('--pilots', help='Download any first episode for a series', action="store_true", default=False)
    prequeue.add_argument('--rss', help='RSS feed to scan for torrent links', required=True)
    prequeue.add_argument('--thost', default='localhost', help='Transmission host name')
    prequeue.add_argument('--tuser', default='transmission', help='Transmission user name')
    prequeue.add_argument('--tpass', default='transmission', help='Transmission password')
    group = prequeue.add_mutually_exclusive_group()
    group.add_argument('--episodes', help='Episodes processing mode', action="store_true", default=False)
    group.add_argument('--movies', help='Movies processing mode', action="store_true", default=False)
    # Postqueue
    postqueue = subparsers.add_parser('postqueue', help='Enable postqueue mode')
    postqueue.add_argument('--tv-shows', help='Folder where TV shows are stored', default=EPISODES_DIR)
    # Kodi functionality
    kodi = subparsers.add_parser('kodi', help='Execute tasks on Kodi')
    kodi.add_argument('--clean', help='Clean the Kodi Video Library', action="store_true", default=False)
    kodi.add_argument('--scan', help='Scan new items to the Kodi Video Library', action="store_true", default=False)
    kodi.add_argument('--episodes', help='Log all TV Shows in the Kodi Video Library', action="store_true", default=False)
    kodi.add_argument('--movies', help='Log all Movies in the Kodi Video Library', action="store_true", default=False)
    # Match pattern against a string (debug)
    match = subparsers.add_parser('match', help='Match a trigram pattern against the provided string')
    match.add_argument('--pattern', help='Pattern to match. Use together with --string', required=True)
    match.add_argument('--string', help='String to match against --pattern. Use with --pattern', required=True)

    # Parse options
    return parser.parse_args()


def get_torrent(item):
    """ """
    # Set the namespace for the find[all]() method
    ns = {'torrent': 'http://xmlns.ezrss.it/0.1/'}
    # First, try the least common torrent:magnetURI
    torrent = item.find(u'torrent:magnetURI', ns)
    if torrent is not None:
        return torrent.text
    # Enclosure
    torrent = item.find(u'enclosure')
    if forrent is not None:
        return torrent.attrib[u'url']
    # Link
    torrent = item.find(u'link')
    if torrent is not None:
        return torrent.text
    # Nothing found
    raise ValueError(u'Could not find torrent link, invalid item?')


def episodes(options):
    """ Prequeue mode """
    log.info(u'Running in prequeue (episodes) mode')
    # Available series
    series = get_series()
    # Episodes that have already been added to transmission
    episodes = []
    # Set the namespace for the findall() method
    ns = {'torrent': 'http://xmlns.ezrss.it/0.1/'}

    # Process each item in the feed
    for item in get_rss(options.rss).iter('item'):
        name = unicode(item.find('title', ns).text)
        log.debug(u'Matching item "{n}"'.format(n=name))
        # Parse title (must be 720p)
        m = match(EPISODES_REGEX, name, I)
        if (m is None):
            # log.debug(u'Unrecognised TV format: "{n}"'.format(n=name))
            continue
        # Fix title and create a Trigram for matching
        title = Trigram(m.group(1))
        log.info(u'Matched candidate title "{t}" for "{n}"'.format(t=title, n=name))

        try:
            # Find the most matching serie with a similarity to title of more than 80%
            serie = find(series, title)
            log.info(u'"{t}" matches against "{s}" by {m}%'.format(t=title, s=serie.s, m=int(serie.similarity(title) * 100)))
            # Find episode details
            episode = Episode(serie, m.group(2), m.group(3))
            if episode in episodes or episode.exists():
                log.info(u'Skipping "{n}", already available'.format(n=name))
                episodes.append(episode)
                continue
            # Add the episode to prevent duplicate items being downloaded
            episodes.append(episode)
        except ValueError as e:
            skip = True
            # Get first episode for new seasons of ANY series
            if options.pilots and 1 == int(m.group(3)):
                skip = False
            # Skip filtering if all items must be downloaded (breaks duplicate file detection in feeds)
            if skip and not options.everything:
                continue

        try:
            # Get the torrent link & upload to transmission
            put_transmission(name, get_torrent(item), options.thost, options.tuser, options.tpass)
        except ValueError as e:
            log.error(e)
            pass


def movies(options):
    """ Prequeue mode """
    log.info(u'Running in prequeue (movies) mode')
    # Available series
    movies = get_movies()

    # Process each item in the feed
    for item in get_rss(options.rss).iter('item'):
        name = unicode(item.find('title').text)
        log.debug(u'Matching item "{n}"'.format(n=name))
        # Parse title against pattern
        m = match(MOVIES_REGEX, name, I)
        if (m is None):
            continue
        # Fix title and create a Trigram for matching
        title = Trigram(m.group(u'title'))
        year = int(m.group(u'year'))
        log.info(u'Matched candidate title "{t} ({y})" for "{n}"'.format(t=title, n=name, y=year))

        try:
            # Match title against available movies
            if (title in movies or year < (date.today().year - 1)) and not options.everything:
                log.info(u'Skipping "{n}", already available or too old'.format(n=name))
                continue
            # Add to movies to prevent duplicate movies download from feed
            movies.append(title)
        except ValueError as e:
            # Movie not found, download
            pass

        try:
            # Get the torrent link & upload to transmission
            put_transmission(name, get_torrent(item), options.thost, options.tuser, options.tpass)
        except ValueError as e:
            log.error(e)
            pass


def postqueue(options):
    """ Postqueue mode """
    log.info(u'Running in postqueue mode')
    # Retrieve transmission environment variables
    filename = unicode(environ['TR_TORRENT_NAME'])
    directory = unicode(environ['TR_TORRENT_DIR'])
    # Source filename or directory
    source = join(directory, filename)
    isDirectory, sourceDir = False, source
    if isdir(source):
        # Find the largest file in the source directory
        chdir(source)
        source = join(source, sorted((getsize(s), s) for s in listdir(source))[-1][1])
        isDirectory = True
    if not isfile(source):
        raise ValueError(u'Source "{s}" is not a file'.format(s=source))

    log.info(u'Processing file "{s}"'.format(s=source))

    # Try to match as a TV shows
    target = filename if isDirectory else splitext(filename)[0]
    m = match(EPISODES_REGEX, target, I)
    if (m is None):
        raise ValueError('Unrecognised TV format: "{f}"'.format(f=filename))
    title = Trigram(m.group(1))

    try:
        # Create a new episode
        episode = Episode(find(get_series(), title), m.group(2), m.group(3))
        if episode.exists():
            log.info(u'Skipping "{s}", already available'.format(s=source))
            return
    except ValueError:
        episode = Episode(title, m.group(2), m.group(3))

    try:
        # Find most matching series on disk
        serie = find([Trigram(x) for x in listdir(options.tv_shows)], title)
    except ValueError:
        # Set title as new series
        serie = title

    # Set umask to a known value
    umask(0)
    # Is a directory available for the current title/season? If not, create it
    destination = join(options.tv_shows, '{t}/Season {s:>02}'.format(t=serie, s=episode.season))
    if not isdir(destination):
        log.info(u'Creating directory "{d}"'.format(d=destination))
        makedirs(destination, 0o755)
    # Compose filename based on matches (file is always a .mkv file)
    filename = '{t}.s{s:>02}e{e:>02}.{g}.mkv'.format(
        t=serie.s.lower().replace('_', '.').replace(' ', '.'),
        s=episode.season,
        e=episode.episode,
        g=m.group(4).lower()
    )
    # Full path for file
    destination = join('{d}/{f}'.format(d=destination, f=filename))
    if isfile(destination):
        raise ValueError(u'Destination file "{d}" already exists'.format(d=destination))
    # Move the file
    log.info(u'Moving file "{s}" to "{d}"'.format(s=source, d=destination))
    move(source, destination)
    # Delete the directory if the source was a directory
    if isDirectory:
        rmtree(sourceDir)
    # Scan the Video Library to add the new file
    scan()


def scan():
    """ """
    log.info(u'Scanning disk for new items to add to the Kodi Video Library')
    kodi = KodiRPC()
    kodi.VideoLibrary.Scan()


def main():
    """ Main entry point.
    """
    try:
        # Parse command line options
        options = parse()
        try:
            # Set up logging
            if options.log:
                handler = logging.FileHandler(options.log)
            else:
                handler = logging.StreamHandler()
            handler.setFormatter(logging.Formatter(u'[%(asctime)s] [%(levelname)s] %(message)s'))  # noqa: E501
            # Add handler to the root log
            logging.root.addHandler(handler)
            # Set log level
            level = logging.DEBUG if options.debug else logging.INFO
            logging.root.setLevel(level)
        except Exception as e:
            return 1

        log.info(u'{s:-^80}'.format(s=u' Start SimpleGet '))

        # Execute mode
        if u'match' == options.mode:
            match_trigram(options.pattern, options.string)
        if u'kodi' == options.mode:
            if options.clean:
                clean()
            if options.episodes:
                kodi_episodes()
            if options.movies:
                kodi_movies()
            if options.scan:
                scan()
        if u'prequeue' == options.mode:
            if options.episodes:
                episodes(options)
            if options.movies:
                movies(options)
        if u'postqueue' == options.mode:
            postqueue(options)

        log.info(u'{s:-^80}'.format(s=u' Finished SimpleGet without errors '))

        # Success
        return 0
    except Exception as e:
        log.error(e)
        log.info(u'{s:-^80}'.format(s=u' Finished SimpleGet WITH errors '))
        # Failure
        return 1


# Call main entry point
if __name__ == '__main__':
    sys.exit(main())
